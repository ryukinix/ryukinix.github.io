---
date: 2017-07-26
tags:
- c++
- programming
- hackerrank
author: Manoel Vilela
layout: post
title: C++ Journey
excerpt: Uma jornada no mundo infernal de C++ através do HackerRank
categories:
- c++
- programming
- hackerrank
comments: true
extra_head: |
<style>
  pre.src {background-color: #303030; color: #e5e5e5}
</style>
---


<div id="outline-container-toc-org" class="outline-2">
<h2 id="toc-org"><a id="sec-1" name="sec-1"></a>Tabela de Conteúdos</h2>
<div class="outline-text-2" id="text-toc-org">
<ul class="org-ul">
<li><a href="#sec-2">Descrição</a><br  />
</li>
<li><a href="#sec-3">HackerRank C++</a><br  />
<ul class="org-ul">
<li><a href="#sec-3-0-1">The Type String</a><br  />
</li>
<li><a href="#sec-3-0-2">Streams</a><br  />
</li>
<li><a href="#sec-3-0-3">Attribute Parser</a><br  />
</li>
<li><a href="#sec-3-1">Orientação a Objetos</a><br  />
<ul class="org-ul">
<li><a href="#sec-3-1-1">Introdução</a><br  />
</li>
<li><a href="#sec-3-1-2">Structs</a><br  />
</li>
<li><a href="#sec-3-1-3">Básico de Classes</a><br  />
</li>
<li><a href="#sec-3-1-4">Class constructors</a><br  />
</li>
<li><a href="#sec-3-1-5">Exceptions</a><br  />
</li>
<li><a href="#sec-3-1-6">Polymorphism and Abstract Base Classes</a><br  />
</li>
</ul>
</li>
<li><a href="#sec-3-2">Inheritance</a><br  />
<ul class="org-ul">
<li><a href="#sec-3-2-1">Inheritance Introduction</a><br  />
</li>
<li><a href="#sec-3-2-2">Rectangle Area</a><br  />
</li>
<li><a href="#sec-3-2-3">Multi Level Inheritance</a><br  />
</li>
<li><a href="#sec-3-2-4">Accessing Inherited Functions</a><br  />
</li>
<li><a href="#sec-3-2-5">Magic Spells</a><br  />
</li>
</ul>
</li>
<li><a href="#sec-3-3">STL - C++ Standard Library</a><br  />
<ul class="org-ul">
<li><a href="#sec-3-3-1">Vector Sort</a><br  />
</li>
<li><a href="#sec-3-3-2">Vector-Erase</a><br  />
</li>
<li><a href="#sec-3-3-3">Lower Bound</a><br  />
</li>
<li><a href="#sec-3-3-4">Sets</a><br  />
</li>
<li><a href="#sec-3-3-5">Maps</a><br  />
</li>
<li><a href="#sec-3-3-6">Print Pretty</a><br  />
</li>
<li><a href="#sec-3-3-7">Deque</a><br  />
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-4">C++ prime checking</a><br  />
</li>
<li><a href="#sec-5">Estudos de caso</a><br  />
<ul class="org-ul">
<li><a href="#sec-5-1">Listas de inicialização para construtores</a><br  />
</li>
<li><a href="#sec-5-2">Separadores de escopo <code>::</code> e <code>.</code></a><br  />
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Descrição</h2>
<div class="outline-text-2" id="text-2">
<p>
Minha jornada com C++ no HackerRank principalmente e outras coisas. Na maioria<br  />
das questões não uso todos os recursos de <code>C++14</code>, mas às vezes sim. Assume-se,<br  />
por via das dúvidas, que todos arquivos estão no padrão <code>C++14</code>.<br  />
</p>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">HackerRank C++</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-sec-3-0-1" class="outline-4">
<h4 id="sec-3-0-1">The Type String</h4>
<div class="outline-text-4" id="text-3-0-1">
<p>
Diferentemente de C, C++ implementa um tipo string não somente como uma cadeia<br  />
de caracteres, mas como um objeto. Possui métodos associados, como length.<br  />
É bem útil.<br  />
</p>


<div class="org-src-container">

<pre class="src src-C++"><span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">inicializa&#231;&#227;o de string</span>
<span style="color: #7CB8BB;">string</span> <span style="color: #DFAF8F;">a</span> = <span style="color: #CC9393;">"abc"</span>;
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">tamanho</span>
a.size()
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">concatena&#231;&#227;o</span>
<span style="color: #7CB8BB;">string</span> <span style="color: #DFAF8F;">b</span> = <span style="color: #CC9393;">"def"</span>
string c = a + b; <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">"abcdef"</span>
</pre>
</div>

<p>
O primeiro exercício do HackerRank:<br  />
</p>

<div class="org-src-container">

<pre class="src src-C++"><span style="color: #94BFF3;">#include</span> <span style="color: #CC9393;">&lt;iostream&gt;</span>
<span style="color: #94BFF3;">#include</span> <span style="color: #CC9393;">&lt;string&gt;</span>
<span style="color: #94BFF3;">#include</span> <span style="color: #CC9393;">&lt;algorithm&gt;</span>
<span style="color: #F0DFAF; font-weight: bold;">using</span> <span style="color: #F0DFAF; font-weight: bold;">namespace</span> <span style="color: #BFEBBF;">std</span>;

<span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">main</span>() {
    <span style="color: #7CB8BB;">string</span> <span style="color: #DFAF8F;">a</span>,<span style="color: #DFAF8F;">b</span>;
    cin &gt;&gt; a;
    cin &gt;&gt; b;
    cout &lt;&lt; a.size() &lt;&lt; <span style="color: #CC9393;">" "</span> &lt;&lt; b.size() &lt;&lt; endl;
    cout &lt;&lt; a + b &lt;&lt; endl;
    <span style="color: #7CB8BB;">char</span> <span style="color: #DFAF8F;">temp</span> = a[0];
    a[0] = b[0];
    b[0] = temp;
    cout &lt;&lt; a &lt;&lt; <span style="color: #CC9393;">" "</span> &lt;&lt; b &lt;&lt; endl;

    <span style="color: #F0DFAF; font-weight: bold;">return</span> 0;
}
</pre>
</div>


<p>
Lidando com tamanho, concatenação e substituição de characteres<br  />
em strings.<br  />
</p>
</div>
</div>

<div id="outline-container-sec-3-0-2" class="outline-4">
<h4 id="sec-3-0-2">Streams</h4>
<div class="outline-text-4" id="text-3-0-2">
<p>
Esse tópico refere-se ao gerenciamento de stream usando strings<br  />
para C++. Muito interessante. O operador &lt;&lt; insere informação,<br  />
por outro lado, o operador &gt;&gt; extrai informação.<br  />
</p>


<p>
O método de inicialização da stringstream cria uma stream. O cabeçalho é <code>&lt;sstream&gt;</code>.<br  />
<a href="https://github.com/ryukinix/cpp-journey/tree/master/Strings/strings-2.cpp">HackerRank-Problem-String</a><br  />
O método sstream::eof verifica se a stream está no fim. EOF = End Of File.<br  />
</p>
</div>
</div>

<div id="outline-container-sec-3-0-3" class="outline-4">
<h4 id="sec-3-0-3">Attribute Parser</h4>
<div class="outline-text-4" id="text-3-0-3">
<p>
Nessa atividade, a última de strings, vou precisar fazer um parser de atributos<br  />
em Cancer++. Um pouco da descrição do site é dada no block de código abaixo.<br  />
</p>

<div class="org-src-container">

<pre class="src src-xml">We have defined our own markup language HRML. In HRML, each element consists of
a starting and ending tag, and there are attributes associated with each tag.
Only starting tags can have attributes. We can call an attribute by referencing
the tag, followed by a tilde, '~' and the name of the attribute.
The tags may also be nested.

Sample Input

4 3
&lt;<span style="color: #93E0E3;">tag1</span> <span style="color: #DFAF8F;">value</span> = <span style="color: #CC9393;">"</span><span style="color: #CC9393;">HelloWorld</span><span style="color: #CC9393;">"</span>&gt;
&lt;<span style="color: #93E0E3;">tag2</span> <span style="color: #DFAF8F;">name</span> = <span style="color: #CC9393;">"</span><span style="color: #CC9393;">Name1</span><span style="color: #CC9393;">"</span>&gt;
&lt;/<span style="color: #93E0E3;">tag2</span>&gt;
&lt;/<span style="color: #93E0E3;">tag1</span>&gt;
tag1.tag2~name
tag1~name
tag1~value

Sample Output

Name1
Not Found!
HelloWorld
</pre>
</div>

<p>
A atividade está sendo desenvolvida no arquivo:<br  />
<a href="https://github.com/ryukinix/cpp-journey/tree/master/Strings/strings-3-attribute-parser.cpp">Attribute Parser</a><br  />
</p>

<p>
Já estou há várias horas resolvendo esse problema. Sinceramente é um pouco<br  />
trabalhoso. Agora é <span class="timestamp-wrapper"><span class="timestamp">&lt;2017-07-06 qui 01:50&gt;</span></span>. Já se passou mais de 8 horas&#x2026;<br  />
que inferno! Mas eu dormi um pouco antes também. Cassete! terminei agora depois<br  />
de 14 horas! Uma completa desgraça! KKK<br  />
</p>

<p>
QUE INFERNO!!!!!! TERMINEI!!!!<br  />
</p>

<p>
Primeiramente interpretei o problema um tanto errado, pensando que a primeira<br  />
tag seria a raíz da árvore. O que deu bastante problema para contornar.<br  />
Após isso havia vários erros, como o não tratamento de espaços antes das chaves,<br  />
como indentação. Isso não parece ter nenhum efeito durante a correção. Mas<br  />
só fui perceber todos os erros após conseguir o SUITE TESTCASE #4 de um<br  />
repositório do github. O problema central, depois de corrigir a modelagem errada,<br  />
era em relação ao método de pesquisa.<br  />
**<br  />
</p>
</div>
</div>
<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Orientação a Objetos</h3>
<div class="outline-text-3" id="text-3-1">
</div>
<div id="outline-container-sec-3-1-1" class="outline-4">
<h4 id="sec-3-1-1">Introdução</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
Estou fazendo alguns exercícios de C++ no HackerRank. Até agora não estou<br  />
com muitos problemas. Na verdade C++ não é tão difícil quanto eu pensei.<br  />
De fato, na verdade, eu nunca tinha parado pra olhar direito como era a<br  />
linguagem e só ficava de tretinha básica.<br  />
</p>

<p>
OO em C++ parece ser divertido, apesar de ainda ter uma impressão cancerígina.<br  />
Não é pra menos&#x2026; keywords, friend, public, private e protected?<br  />
Mas, enfim, acho que vou conseguir me acostumar. Quero terminar hoje ainda a<br  />
introdução, estou na última parte envolvendo OO, herança e variáveis estáticas.<br  />
</p>

<p>
Método virtuais em C++ são usados para fazer polimorfismo dinâmicos em heranças.<br  />
Protected são membros acessíveis apenas pelas subclasses. Private são<br  />
acessíveis apenas pelos métodos da classe. Public são publicos para todos.<br  />
</p>

<p>
Por padrão, membros são privados em classes. É possível usar a keyword friend<br  />
para acessar atributos privados de outra classe. Provavelmente eu não deveria<br  />
estar falando desses tópicos avançados de OO na introdução (HAHAH!). Mas<br  />
é bom que dá o gostinho de desgraça que C++ tem tanto de especial.<br  />
</p>
<div class="org-src-container">

<pre class="src src-C++"><span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">NUMBER_OF_MARKS</span> = 6;

<span style="color: #F0DFAF; font-weight: bold;">class</span> <span style="color: #7CB8BB;">Person</span> {
<span style="color: #F0DFAF; font-weight: bold;">protected</span>:
    <span style="color: #7CB8BB;">string</span> <span style="color: #DFAF8F;">name</span>;
    <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">age</span>;
<span style="color: #F0DFAF; font-weight: bold;">public</span>:
    <span style="color: #F0DFAF; font-weight: bold;">virtual</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">putdata</span>(<span style="color: #7CB8BB;">void</span>){};
    <span style="color: #F0DFAF; font-weight: bold;">virtual</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">getdata</span>(<span style="color: #7CB8BB;">void</span>){};
};

<span style="color: #F0DFAF; font-weight: bold;">class</span> <span style="color: #7CB8BB;">Professor</span>: <span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">Person</span> {
<span style="color: #F0DFAF; font-weight: bold;">private</span>:
    <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">publications</span>;
    <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">cur_id</span>;
<span style="color: #F0DFAF; font-weight: bold;">public</span>:
    <span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">count</span>;
    <span style="color: #93E0E3;">Professor</span>(<span style="color: #7CB8BB;">void</span>){
        cur_id = count + 1;
        count += 1;
    }
    <span style="color: #F0DFAF; font-weight: bold;">virtual</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">putdata</span>(<span style="color: #7CB8BB;">void</span>) {
        <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">The function putdata should print the name, age,</span>
        <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">publications and the cur_id of the professor.</span>
        cout &lt;&lt; name &lt;&lt; <span style="color: #CC9393;">" "</span>;
        cout &lt;&lt; age &lt;&lt; <span style="color: #CC9393;">" "</span>;
        cout &lt;&lt; publications &lt;&lt; <span style="color: #CC9393;">" "</span>;
        cout &lt;&lt; cur_id &lt;&lt; endl;
    }

    <span style="color: #F0DFAF; font-weight: bold;">virtual</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">getdata</span>(<span style="color: #7CB8BB;">void</span>) {
        cin &gt;&gt; name;
        cin &gt;&gt; age;
        cin &gt;&gt; publications;
    }
};

<span style="color: #F0DFAF; font-weight: bold;">class</span> <span style="color: #7CB8BB;">Student</span>: <span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">Person</span> {
<span style="color: #F0DFAF; font-weight: bold;">private</span>:
    <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">marks</span>[NUMBER_OF_MARKS];
    <span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">_sum_marks</span>() {
        <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">total</span> = 0;
        <span style="color: #F0DFAF; font-weight: bold;">for</span> (<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">i</span> = 0; i &lt; NUMBER_OF_MARKS; i++) {
            total += marks[i];
        }
        <span style="color: #F0DFAF; font-weight: bold;">return</span> total;
    }
    <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">cur_id</span>;
<span style="color: #F0DFAF; font-weight: bold;">public</span>:
    <span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">count</span>;
    <span style="color: #93E0E3;">Student</span>(<span style="color: #7CB8BB;">void</span>) {
        cur_id = count + 1;
        count += 1;
    }
    <span style="color: #F0DFAF; font-weight: bold;">virtual</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">putdata</span>(<span style="color: #7CB8BB;">void</span>) {
        <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">The function putdata should print the name, age,</span>
        <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">sum of the marks and the cur_id of the student.</span>
        cout &lt;&lt; name &lt;&lt; <span style="color: #CC9393;">" "</span>;
        cout &lt;&lt; age &lt;&lt; <span style="color: #CC9393;">" "</span>;
        cout &lt;&lt; _sum_marks() &lt;&lt; <span style="color: #CC9393;">" "</span>;
        cout &lt;&lt; cur_id &lt;&lt; endl;

    }

    <span style="color: #F0DFAF; font-weight: bold;">virtual</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">getdata</span>(<span style="color: #7CB8BB;">void</span>) {
        cin &gt;&gt; name;
        cin &gt;&gt; age;
        <span style="color: #F0DFAF; font-weight: bold;">for</span> (<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">i</span> = 0; i &lt; NUMBER_OF_MARKS; i++){
            cin &gt;&gt; marks[i];
        }

    }

};

<span style="color: #7CB8BB;">int</span> <span style="color: #BFEBBF;">Professor</span>::<span style="color: #DFAF8F;">count</span> = 0;
<span style="color: #7CB8BB;">int</span> <span style="color: #BFEBBF;">Student</span>::<span style="color: #DFAF8F;">count</span> = 0;
</pre>
</div>

<p>
Construtores podem ser definidos uma ou várias vezes.<br  />
No entanto, destrutores só podem ser definidos uma vez.<br  />
</p>
</div>
</div>

<div id="outline-container-sec-3-1-2" class="outline-4">
<h4 id="sec-3-1-2">Structs</h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
Os structs em C++ são semelhantes de C, no entanto eles são como classes<br  />
com membros e métodos públicos por padrão. Usualmente structs são usados apenas<br  />
para agrupar membros de variáveis numa estrutura compartilhada, podendo assim,<br  />
criar estrutura de dados mais complexas.<br  />
</p>
</div>
</div>

<div id="outline-container-sec-3-1-3" class="outline-4">
<h4 id="sec-3-1-3">Básico de Classes</h4>
<div class="outline-text-4" id="text-3-1-3">
<p>
Por padrão classes tem seus métodos e atributos privados, sendo reservado as<br  />
keywords para controle de acesso: protected, private e public.<br  />
Uma prática comum em C++ é deixar todos os atributos privados ou protecteds<br  />
(case for uma classe base de herança), então criar getters e setters públicos.<br  />
</p>

<p>
Um exemplo de código abaixo é dado:<br  />
</p>

<div class="org-src-container">

<pre class="src src-C++"><span style="color: #F0DFAF; font-weight: bold;">class</span> <span style="color: #7CB8BB;">Student</span> {
<span style="color: #F0DFAF; font-weight: bold;">private</span>:
    <span style="color: #7CB8BB;">string</span> <span style="color: #DFAF8F;">name</span>;
    <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">age</span>;
<span style="color: #F0DFAF; font-weight: bold;">public</span>:
    <span style="color: #7CB8BB;">string</span> <span style="color: #93E0E3;">get_mame</span>() {
        <span style="color: #F0DFAF; font-weight: bold;">return</span> name;
    }

    <span style="color: #7CB8BB;">string</span> <span style="color: #93E0E3;">get_age</span>() {
        <span style="color: #F0DFAF; font-weight: bold;">return</span> age;
    }

    <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">set_name</span>(<span style="color: #7CB8BB;">string</span> <span style="color: #DFAF8F;">new_name</span>) {
        name = new_name;
    }

    <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">set_age</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">new_age</span>) {
        age = new_age;
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-1-4" class="outline-4">
<h4 id="sec-3-1-4">Class constructors</h4>
<div class="outline-text-4" id="text-3-1-4">
<p>
Construtores são chamados na inicialização de uma classe. Podem possuir um ou mais,<br  />
com diferentes assinaturas.<br  />
Os tipos de construtores são três:<br  />
</p>
<ol class="org-ol">
<li>Construtor padrão<br  />
</li>
<li>Construtor parametrizado<br  />
</li>
<li>Construtor de Cópia<br  />
</li>
</ol>

<p>
Exemplo: <a href="https://github.com/ryukinix/cpp-journey/tree/master/Classes/constructor.cpp">ConstructorsExample.cpp</a><br  />
</p>
</div>
</div>

<div id="outline-container-sec-3-1-5" class="outline-4">
<h4 id="sec-3-1-5">Exceptions</h4>
<div class="outline-text-4" id="text-3-1-5">
<p>
C++ permite criar exceções personalizadas ao criar uma herança da classe<br  />
<code>exception</code>. O método descritivo da exceção é <code>const char* what(){}</code>.<br  />
Uma atividade simples foi feita em: <a href="https://github.com/ryukinix/cpp-journey/tree/master/Classes/exception.cpp">Exceptions.cpp</a><br  />
Blocos <code>try/catch</code> são usados pra lidar com exceções que ocorreram.<br  />
<code>throw Exception();</code> é usado para sinalizar uma exceção.<br  />
</p>

<p>
Minha próxima atividade no HackerRank é a respeito de um servidor para<br  />
capturar exceções customizadas.<br  />
<a href="https://github.com/ryukinix/cpp-journey/tree/master/Classes/CustomExceptions.cpp">CustomExceptions.cpp</a><br  />
</p>

<p>
Todas as exceções padrões tem como base classe <code>std::exception</code>.<br  />
Uma maneira simples de capturar uma exceção e imprimi-la, é desta maneira:<br  />
</p>

<div class="org-src-container">

<pre class="src src-C++"><span style="color: #94BFF3;">#include</span> <span style="color: #CC9393;">&lt;exception&gt;</span> <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">defini&#231;&#227;o da classe base std::exception</span>
<span style="color: #94BFF3;">#include</span> <span style="color: #CC9393;">&lt;stdexcept&gt;</span> <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">v&#225;rias exce&#231;&#245;es padr&#245;es para ser usadas</span>
<span style="color: #F0DFAF; font-weight: bold;">try</span> {
    <span style="color: #BFEBBF;">std</span>::cout &lt;&lt; 1/0;
} <span style="color: #F0DFAF; font-weight: bold;">catch</span>(<span style="color: #BFEBBF;">std</span>::<span style="color: #7CB8BB;">exception</span> <span style="color: #F0DFAF; font-weight: bold;">const</span>&amp; <span style="color: #DFAF8F;">e</span>) {
    <span style="color: #BFEBBF;">std</span>::cout &lt;&lt; <span style="color: #CC9393;">"Erro do capeta: "</span> &lt;&lt; e.what();
} <span style="color: #F0DFAF; font-weight: bold;">catch</span>(...) {
    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">essa sess&#227;o captura qualquer exce&#231;&#227;o n&#227;o esperada</span>
}
</pre>
</div>

<p>
Exceções definidas no cabeçalho &lt;stdexcept&gt;<br  />
</p>
<ul class="org-ul">
<li><code>bad_alloc</code><br  />
</li>
<li><code>bad_cast</code><br  />
</li>
<li><code>bad_exception</code><br  />
</li>
<li><code>bad_typeid</code><br  />
</li>
<li><code>logic_error</code><br  />
<ul class="org-ul">
<li><code>domain_error</code><br  />
</li>
<li><code>invalid_argument</code><br  />
</li>
<li><code>length_error</code><br  />
</li>
<li><code>out_of_range</code><br  />
</li>
</ul>
</li>
<li><code>runtime_error</code><br  />
<ul class="org-ul">
<li><code>range_error</code><br  />
</li>
<li><code>overflow_error</code><br  />
</li>
<li><code>underflow_error</code><br  />
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-1-6" class="outline-4">
<h4 id="sec-3-1-6">Polymorphism and Abstract Base Classes</h4>
<div class="outline-text-4" id="text-3-1-6">
<p>
Comecei a fazer essa atividade agora às <span class="timestamp-wrapper"><span class="timestamp">&lt;2017-07-06 qui 20:51&gt;</span></span>.<br  />
Polimorfismo é quando um método na herança é modificado. Em C++<br  />
existem as chamadas Classes Abstratas de Base, onde é permitido que elas<br  />
possuam apenas métodos virtuais para futuramente, numa herança, realizar<br  />
polimorfismo.<br  />
</p>

<p>
Essa última atividade é bem <i>cabulosa</i>. O objetivo é implementar um sistema<br  />
de <i>cache</i> usando listas duplamente encadeadas e, além disso, fazer de tal maneira<br  />
que use os conceitos referentes a polimorfismo numa classe chamada Cache.<br  />
</p>

<p>
As atividades a serem desenvolvidas aqui podem ser encontradas em:<br  />
<a href="https://github.com/ryukinix/cpp-journey/tree/master/Classes/AbstractPolymorphism.cpp">AbstractPolymorphism.cpp</a>.<br  />
</p>

<p>
Depois de um dia tentando ter um progresso com essa atividade, já consegui<br  />
implementar a funcionalidade básica do <code>Cache</code>. No entanto, os testes com maiores<br  />
entradas estão com problemas. De acordo com a execução do HackerRank, está<br  />
ocorrendo <code>segfault</code>. Acredito que possa ser devido o não tratamento direto<br  />
da desalocação dos objetos Nó durante a chamada de void pop_node(); que<br  />
desaloca a cauda da lista. Contínuo essa atividade mais tarde.<br  />
</p>

<p>
De fato durante o <code>pop_node()</code>; há um vazamento de memória. A referência do objeto<br  />
é perdida, mas no entanto o objeto em si não é removido. Foi realizado uma<br  />
verificação manual na versão deste <a href="https://github.com/ryukinix/cpp-journey/tree/master/commit/bb6741d41c74cca1974bb41f3cd0f865a0d7be2c">commit</a>.<br  />
A estratégia assumida é para gerenciar corretamente a memória durante as novas<br  />
alocações.<br  />
</p>

<p>
Como eu suspeitava, a função `LRUCache::pop_node()` que estava vazando memória.<br  />
Após a adição das instruções pra desalocar tanto a cauda como também a entrada<br  />
desse nó no <code>HashMap mp</code>, os testes do HackerRank passaram. Mas demorei demais pra<br  />
fazer tudo. Quase 30 horas! Bem que no HackerRank comentava que era uma questão<br  />
difícil.<br  />
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Inheritance</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Este é um tópico especial envolvendo como funciona o conceito de herança<br  />
em C++, todo mal da orientação objetos, como também é uma prática comum<br  />
em muitos projetos que usam linguagens como C++.<br  />
</p>

<p>
Estarei linkando nos próximos títulos os códigos-fontes de cada<br  />
solução das questões.<br  />
</p>
</div>

<div id="outline-container-sec-3-2-1" class="outline-4">
<h4 id="sec-3-2-1">Inheritance Introduction</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
Nessa atividade é pedido pra construir um método de descrição de uma subclasse<br  />
de Triangle chamada Isosceles. A construção é bem direta e não é necessário<br  />
muita explicação. É tão estúpida que até pensei em não deixar o código fonte aqui.<br  />
Mas vamos lá&#x2026; <a href="https://github.com/ryukinix/cpp-journey/tree/master/Inheritance/TriangleInheritance.cpp">TriangleInheritance.cpp</a><br  />
</p>
</div>
</div>

<div id="outline-container-sec-3-2-2" class="outline-4">
<h4 id="sec-3-2-2">Rectangle Area</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
Nesta atividade será feito um exercício para cálculo<br  />
da área de um retângulo usando os conceitos de herança. Durante<br  />
a construção da solução foi possível perceber que era possível<br  />
chamar métodos da classe base com mesmo nome, no caso ambos possuiam<br  />
o método void display, mas a instância do objeto era RectangleArea.<br  />
Para acessar então, display de Rectangle, foi necessário a seguinte<br  />
sintaxe:<br  />
</p>

<div class="org-src-container">

<pre class="src src-C++"><span style="color: #7CB8BB;">RectangleArea</span> <span style="color: #DFAF8F;">r_area</span>;
r_area.<span style="color: #BFEBBF;">Rectangle</span>::display();
</pre>
</div>

<p>
A solução completa pode ser encontrada aqui:<br  />
<a href="https://github.com/ryukinix/cpp-journey/tree/master/Inheritance/RectangleArea.cpp">RectangleArea.cpp</a><br  />
</p>
</div>
</div>

<div id="outline-container-sec-3-2-3" class="outline-4">
<h4 id="sec-3-2-3">Multi Level Inheritance</h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
     É possível fazer herança em mais de um nível. Um exemplo é dado<br  />
no exercício para a construção de uma classe Equilateral, que deriva<br  />
de Isosceles, que é derivado de Triangle. Isso demonstra a interdependência<br  />
das propriedades que uma instância de Equilateral tem entre Isosceles<br  />
e Triangle. O que é realmente verdade, já que um triângulo Equilátero<br  />
é obviamente também um Triângulo e é Isósceles.<br  />
</p>

<p>
A atividade foi direta de ser completa e está descrita a seguir:<br  />
<a href="https://github.com/ryukinix/cpp-journey/tree/master/Inheritance/IsoscelesEquilateral.cpp">IsoscelesEquilateral.cpp</a><br  />
</p>
</div>
</div>

<div id="outline-container-sec-3-2-4" class="outline-4">
<h4 id="sec-3-2-4">Accessing Inherited Functions</h4>
<div class="outline-text-4" id="text-3-2-4">
<p>
     Como comentada na questão Rectangle Area, é possível acessar<br  />
funções/métodos da classe base que foi herdada. Nessa atividade<br  />
irei descrever brevemente a implementação do exercício proposto no<br  />
HackerRank.<br  />
</p>

<p>
A atividade é descrita em: <a href="https://github.com/ryukinix/cpp-journey/tree/master/Inheritance/AcessingInheritedFunctions.cpp">AcessingInheritedFunctions.cpp</a><br  />
</p>

<p>
A questão pede para se chegar a um número de entrada usando apenas as classes<br  />
de base A, B e C.<br  />
</p>
</div>
</div>
<div id="outline-container-sec-3-2-5" class="outline-4">
<h4 id="sec-3-2-5">Magic Spells</h4>
<div class="outline-text-4" id="text-3-2-5">
<p>
Lá vem questão <b>HARD</b> de novo diretamente do inferno no HackerRank. Essa questão<br  />
envolve o uso de herança e <code>dynamic_cast</code>, que é basicamente o que tentei fazer<br  />
uma vez em C e só me fudi (uma variável de tipo dinâmico, acabei terminando com um <code>union</code> e <code>enum</code>).<br  />
Parece que C++ implementa algo parecido do que eu desejei pra lidar com esse tipo de problema.<br  />
</p>

<p>
Nesse caso <code>dynamic_cast</code> é usado para modelar uma instância compatível com outro tipo<br  />
ou classe. Se um <code>nullptr</code> é retornado, significa que os tipos não são compatíveis.<br  />
Nessa questão isso é usado para saber que tipo de que classe derivada de <code>Spell</code><br  />
foi instanciada. A sintaxe é dada por <code>dynamic_cast&lt;Type*&gt;(instance*)</code>. Muito<br  />
semelhante ao cast estático de C.<br  />
</p>

<p>
Estou tendo alguns problemas para construir um algoritmo do tipo LCS.<br  />
Isto é: Longest Common Substring. Quando o spell é da classe Base, out seja,<br  />
um tipo de magia desconhecida, é necessário que o mago olhe no catálogo de magias<br  />
e compare o nome da magia com o que foi recebido. Dada as duas strings, a recebida<br  />
e a do catálogo, devo retornar o tamanho da substring maior.<br  />
</p>

<p>
Ou seja, é dado o exemplo que para AquaVitae e AruTaVae a maior substring é<br  />
AuaVae. Não tenho tanta certeza se isso está correto, mas achei um código exemplo<br  />
em C++ pra testar. Está linkado em <a href="https://github.com/ryukinix/cpp-journey/tree/master/Inheritance/LongestCommonSubstring.cpp">LongestCommonSubstring.cpp</a><br  />
</p>

<p>
Minha desconfiança sobre isso é da natureza que esse exemplo não retorna<br  />
exatamente a maior substring e sim a maior cadeia possível em sequência, se<br  />
necessário, removendo o que tiver no meio entre elas.<br  />
</p>

<p>
Vou dar uma pausa aqui nessa atividade agora às <span class="timestamp-wrapper"><span class="timestamp">&lt;2017-07-08 sáb 13:48&gt;</span></span>.<br  />
Depois vou tentar voltar mais tarde. A parte inicial da atividade está feita<br  />
em: <a href="https://github.com/ryukinix/cpp-journey/tree/master/Inheritance/MagicSpells.cpp">MagicSpells.cpp</a><br  />
</p>

<p>
Estou de volta nessa atividade dos demônios. Realmente a detecção das classes<br  />
filhas ao usar dynamic cast estão funcionando bem. Na verdade dynamic cast é<br  />
um pouco diferente do que pensei, você não pode fazer conversão de tipos<br  />
arbitrários, mas sim àqueles que são possíveis. Como no caso de um instância<br  />
Pai para uma classe Filha (derivada, herdada).<br  />
</p>

<p>
No entanto estou com problemas demais em relação a desgraça do algoritmo<br  />
para de cálculo de maior substring recorrente entre duas strings, pois esse<br  />
problema de fato não é o Longest Common Substring. Vou precisar fazer um algoritmo<br  />
personalizado pra isso. Talvez eu devesse começar fazendo em Python pra facilitar<br  />
a lógica e depois passar pra Câncer++.<br  />
</p>

<p>
Agora tudo faz sentido, eu estava tentando resolver um problema com a solução<br  />
para outro tipo de problema. Esse problema na verdade tem outro nome. Apesar<br  />
de semelhante ao Longest Common Substring, este se chama Longest Common<br  />
Subsequence. Uma solução em Python transcrita de um pseudo código pode ser vista<br  />
abaixo:<br  />
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">LCSLength</span>(X, Y):
    <span style="color: #F0DFAF; font-weight: bold;">from</span> pprint <span style="color: #F0DFAF; font-weight: bold;">import</span> pprint
    <span style="color: #DFAF8F;">m</span>, <span style="color: #DFAF8F;">n</span> = <span style="color: #DCDCCC; font-weight: bold;">len</span>(X) + 1, <span style="color: #DCDCCC; font-weight: bold;">len</span>(Y) + 1
    <span style="color: #DFAF8F;">C</span> = [[0 <span style="color: #F0DFAF; font-weight: bold;">for</span> _ <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">range</span>(n)] <span style="color: #F0DFAF; font-weight: bold;">for</span> _ <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">range</span>(m)]
    <span style="color: #F0DFAF; font-weight: bold;">for</span> i <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">range</span>(1, m):
        <span style="color: #F0DFAF; font-weight: bold;">for</span> j <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">range</span>(1, n):
            <span style="color: #F0DFAF; font-weight: bold;">if</span> X[i-1] == Y[j-1]:
                C[i][j] = C[i-1][j-1] + 1
            <span style="color: #F0DFAF; font-weight: bold;">else</span>:
                C[i][j] = <span style="color: #DCDCCC; font-weight: bold;">max</span>(C[i][j-1], C[i-1][j])
    pprint(C)
    <span style="color: #F0DFAF; font-weight: bold;">return</span> C[n-1][m-1]
</pre>
</div>

<p>
Vou tentar agora codificar isso em C++. Finalizado. Que desgraça hein.<br  />
A parte mais difícil desse problema não era exatamente lidar com o dynamic_cast<br  />
e detectar que classe filha estão sendo referenciadas. Na verdade esse problema<br  />
aí do Longest Common Subsequence é bem mais difícil. Engraçado porque esse tópico<br  />
é sobre herança, o que esse problema NP-Hard é simplemente sem relação!<br  />
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">STL - C++ Standard Library</h3>
<div class="outline-text-3" id="text-3-3">
</div>
<div id="outline-container-sec-3-3-1" class="outline-4">
<h4 id="sec-3-3-1">Vector Sort</h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
A Standard Library de C++ vem com muitos bultins. Um dos métodos<br  />
da biblioteca é std::sort(vector::begin, vector::end).<br  />
</p>

<div class="org-src-container">
<label class="org-src-name">Ordenar n números</label>
<pre class="src src-C++"><span style="color: #94BFF3;">#include</span> <span style="color: #CC9393;">&lt;cmath&gt;</span>
<span style="color: #94BFF3;">#include</span> <span style="color: #CC9393;">&lt;cstdio&gt;</span>
<span style="color: #94BFF3;">#include</span> <span style="color: #CC9393;">&lt;vector&gt;</span>
<span style="color: #94BFF3;">#include</span> <span style="color: #CC9393;">&lt;iostream&gt;</span>
<span style="color: #94BFF3;">#include</span> <span style="color: #CC9393;">&lt;algorithm&gt;</span>
<span style="color: #F0DFAF; font-weight: bold;">using</span> <span style="color: #F0DFAF; font-weight: bold;">namespace</span> <span style="color: #BFEBBF;">std</span>;


<span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">main</span>() {
    <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">n</span>, <span style="color: #DFAF8F;">x</span>;
    cin &gt;&gt; n;
    <span style="color: #7CB8BB;">vector</span>&lt;<span style="color: #7CB8BB;">int</span>&gt; <span style="color: #DFAF8F;">v</span>;
    <span style="color: #F0DFAF; font-weight: bold;">for</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">i</span> = 0; i &lt; n; i++) {
        cin &gt;&gt; x;
        v.push_back(x);
    }
    sort(v.begin(), v.end());
    <span style="color: #F0DFAF; font-weight: bold;">for</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">x</span> :v) {
        cout &lt;&lt; x &lt;&lt; <span style="color: #CC9393;">" "</span>;
    }
    <span style="color: #F0DFAF; font-weight: bold;">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3-2" class="outline-4">
<h4 id="sec-3-3-2">Vector-Erase</h4>
<div class="outline-text-4" id="text-3-3-2">
<p>
A STL definida em &lt;algorithm&gt; e &lt;vector&gt; define alguns métodos<br  />
úteis, como por exemplo o método vector::erase para remover elementos<br  />
seja de apenas 1 localização, ou um intervalo.<br  />
</p>

<p>
O seguinte código foi feito para o exercício proposto do hackerrank:<br  />
</p>
<div class="org-src-container">

<pre class="src src-C++"><span style="color: #94BFF3;">#include</span> <span style="color: #CC9393;">&lt;cmath&gt;</span>
<span style="color: #94BFF3;">#include</span> <span style="color: #CC9393;">&lt;cstdio&gt;</span>
<span style="color: #94BFF3;">#include</span> <span style="color: #CC9393;">&lt;vector&gt;</span>
<span style="color: #94BFF3;">#include</span> <span style="color: #CC9393;">&lt;iostream&gt;</span>
<span style="color: #94BFF3;">#include</span> <span style="color: #CC9393;">&lt;algorithm&gt;</span>
<span style="color: #F0DFAF; font-weight: bold;">using</span> <span style="color: #F0DFAF; font-weight: bold;">namespace</span> <span style="color: #BFEBBF;">std</span>;


<span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">main</span>() {
    <span style="color: #7CB8BB;">vector</span>&lt;<span style="color: #7CB8BB;">long</span>&gt; <span style="color: #DFAF8F;">v</span>;
    <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">n</span>,<span style="color: #DFAF8F;">x</span>,<span style="color: #DFAF8F;">a</span>,<span style="color: #DFAF8F;">b</span>;
    cin &gt;&gt; n;
    <span style="color: #F0DFAF; font-weight: bold;">for</span> (<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">i</span> = 0; i &lt; n; i++) {
        cin &gt;&gt; x;
        v.push_back(x);
    }

    cin &gt;&gt; x;
    v.erase(v.begin()+x-1);
    cin &gt;&gt; a;
    cin &gt;&gt; b;
    v.erase(v.begin()+a-1, v.begin()+b-1);
    cout &lt;&lt; v.size() &lt;&lt; endl;

    <span style="color: #F0DFAF; font-weight: bold;">for</span> (<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">x</span> : v) {
        cout &lt;&lt; x &lt;&lt; <span style="color: #CC9393;">" "</span>;
    }
    <span style="color: #F0DFAF; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
Ou seja, há duas definições para vector::erase.<br  />
</p>
<ul class="org-ul">
<li>vector::erase(const iterator n);<br  />
</li>
<li>vector::erase(const iterator n, const iterator m);<br  />
</li>
</ul>

<p>
O const iterator pode ser obtido a partido dos métodos:<br  />
vector::begin e vector::end.<br  />
</p>
</div>
</div>

<div id="outline-container-sec-3-3-3" class="outline-4">
<h4 id="sec-3-3-3">Lower Bound</h4>
<div class="outline-text-4" id="text-3-3-3">
<p>
Em C++ a STL provém funções úteis para iterações e comparações.<br  />
Um delas são os métodos std::lower_bound e std::upper_bound.<br  />
Ambas funções recebem três parâmetros, os dois primeiros sendo<br  />
o iterador inicial então o iterador final (vector::begin &amp; vector::end).<br  />
O terceiro elemento é um objeto de comparação que implementa operator&lt;<br  />
para std::lower_bound e std::upper_bound.<br  />
</p>

<p>
O método std::lower_bound retorna o número menor que a comparação que esteja<br  />
mais próximo desse número esquerda. std::upper_bound retorna o maior número que esteja<br  />
mais próximo desse pela direita. Isso, é claro supondo um vetor ordenado.<br  />
</p>

<p>
Pode-se encontrar uma solução para este problema no arquivo:<br  />
<a href="https://github.com/ryukinix/cpp-journey/tree/master/STL/LowerBound.cpp">LowerBound.cpp</a><br  />
</p>
</div>
</div>

<div id="outline-container-sec-3-3-4" class="outline-4">
<h4 id="sec-3-3-4">Sets</h4>
<div class="outline-text-4" id="text-3-3-4">
<p>
Essa próxima atividade se refere a implementação de conjuntos na biblioteca<br  />
padrão de C++. Definida no cabeçalho <code>#include &lt;set&gt;</code> os métodos conhecidos para<br  />
o tipo set, são:<br  />
</p>

<ul class="org-ul">
<li>std::set&lt;int&gt; s;<br  />
</li>
<li>s.length(); // tamanho do conjunto<br  />
</li>
<li>s.erase(int n); // apagar um elemento<br  />
</li>
<li>s.insert(int n); // inserir um elemento<br  />
</li>
<li>set&lt;int&gt;::iterator it = s.find(int n); // procura um elemento, devolve um iterator<br  />
</li>
</ul>

<p>
Se o elemento não é encontrado it == s.end();<br  />
</p>

<p>
Um problema para explorar essas operações é proposto no HackerRank,<br  />
onde uma solução pode ser encontrada aqui: <a href="https://github.com/ryukinix/cpp-journey/tree/master/STL/Set.cpp">Set.cpp</a><br  />
</p>
</div>
</div>

<div id="outline-container-sec-3-3-5" class="outline-4">
<h4 id="sec-3-3-5">Maps</h4>
<div class="outline-text-4" id="text-3-3-5">
<p>
HashMaps são implementados em C++ pela STL, Standard Library. Também conhecidos<br  />
em outras linguagens como dicionários (python), HashMaps armazenam unidades de<br  />
de pares &lt;chave, valor&gt; na qual a existência para uma dada chave é única.<br  />
</p>

<p>
Existem alguns métodos úteis implementados para HashMaps. O tipo é definido<br  />
em <code>#include &lt;map&gt;</code> e segue que:<br  />
</p>

<div class="org-src-container">

<pre class="src src-C++"><span style="color: #94BFF3;">#include</span> <span style="color: #CC9393;">&lt;map&gt;</span>

<span style="color: #BFEBBF;">std</span>::<span style="color: #7CB8BB;">map</span>&lt;<span style="color: #7CB8BB;">int</span>, <span style="color: #7CB8BB;">string</span>&gt; <span style="color: #DFAF8F;">m</span>; <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">declara&#231;&#227;o</span>
m.insert(<span style="color: #BFEBBF;">std</span>::make_pair(1, <span style="color: #CC9393;">"banana"</span>)); <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">inser&#231;&#227;o</span>
m[1] = <span style="color: #CC9393;">"banana"</span>; <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">a&#231;ucar sint&#225;tico para inser&#231;&#227;o</span>
m.erase(<span style="color: #CC9393;">"banana"</span>); <span style="color: #5F7F5F;">//</span><span style="color: #7F9F7F;">remover elemento</span>
m.find(key); <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">m&lt;int,string&gt;::iterator</span>
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">se um elemento n&#227;o &#233; encontrado ent&#227;o m.find(key) == m.end();</span>
m[1]; <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">"banana</span>
</pre>
</div>

<p>
Um problema é proposto no HackerRank para explorar essas operações.<br  />
A implementação está feita no arquivo <a href="https://github.com/ryukinix/cpp-journey/tree/master/STL/HashMap.cpp">HashMap.cpp</a>.<br  />
</p>
</div>
</div>

<div id="outline-container-sec-3-3-6" class="outline-4">
<h4 id="sec-3-3-6">Print Pretty</h4>
<div class="outline-text-4" id="text-3-3-6">
<p>
Preciso fazer essa atividade. Irei começar daqui a pouco. Basicamente<br  />
a atividade é em relação a imprimir diferente tipos de dados com uma determinada<br  />
característica. Por exemplos, notação científica para decimais. Números<br  />
decimais prefixado e também números inteiros com caracteres prefixado.<br  />
Parece que STL já implementa isso em algum lugar.<br  />
</p>

<p>
A atividade será desenvolvida em: <a href="https://github.com/ryukinix/cpp-journey/tree/master/STL/PrettyPrint.cpp">PrettyPrint.cpp</a><br  />
</p>

<p>
Maiores anotações virão a seguir.<br  />
</p>

<p>
Bem&#x2026; trabalhar com formatação de IO em C++ é no mínimo doloroso.<br  />
Na verdade eu achei um completo inferno, mas vou tentar descrever algumas coisas<br  />
que entendi.<br  />
</p>

<p>
No cabeçalho <code>&lt;iomanip&gt;</code> é definido várias entradas para trabalhar com formatação<br  />
de stringstreams, ou necessariamente IO.<br  />
</p>

<p>
Entre diretrizes pra trabalhar com números de qualquer tipo tem-se:<br  />
</p>

<ul class="org-ul">
<li><code>showbase</code> &#x2013; mostra a base do número, como hex e octal<br  />
</li>
<li><code>noshowbase</code> &#x2013; desativa a opção acima<br  />
</li>
<li><code>showpos</code> &#x2013; todos números são definidos com sinal prefixado +/-<br  />
</li>
<li><code>noshowpos</code> &#x2013; desativa a opção acima<br  />
</li>
<li><code>setbase</code> &#x2013; define qual é a base no parsing, por exemplo 16 -&gt; hexadecimal<br  />
</li>
<li><code>uppercase</code> &#x2013; base e outros caracteres são usados em uppercase<br  />
</li>
<li><code>nouppercase</code> &#x2013; o contrário da opção acima<br  />
</li>
</ul>

<p>
Para setbase temos atalhos predefinidos como <code>hex</code>, <code>oct</code> e <code>dec</code>.<br  />
</p>

<p>
Para preenchimento de string, largura máxima e alinhamento temos:<br  />
</p>

<ul class="org-ul">
<li><code>left</code> &#x2013; alinha pela esquerda<br  />
</li>
<li><code>right</code> &#x2013; alinha pela direita<br  />
</li>
<li><code>internal</code> &#x2013; aplica a formação no número em si<br  />
</li>
<li><code>setw</code> &#x2013; define largura máxima<br  />
</li>
<li><code>setfill</code> &#x2013; recebe um caracter e preenche de acordo com a largura máxima esperada<br  />
</li>
</ul>

<p>
Para processamento de números flutuantes temos:<br  />
</p>

<ul class="org-ul">
<li><code>setprecision</code> &#x2013; precisão em casas decimais<br  />
</li>
<li><code>fixed</code> &#x2013; notação prefixa =&gt; 10.001<br  />
</li>
<li><code>scientific</code> &#x2013; notação científica-&gt; 3.30303E+03<br  />
</li>
<li><code>default</code> &#x2013; notação padrão<br  />
</li>
</ul>

<p>
Também tem hexfloat, mas isso é muito obscuro e não vou cobrir.<br  />
</p>

<p>
Para fazer uma definição global de formação podemos usar <code>setiosflags</code> e <code>resetiosflags</code>.<br  />
</p>

<p>
<code>setiosflags</code> recebe uma das <code>flags</code> acima não-parametrizada e define globalmente.<br  />
Como o argumento esperado é uma <code>bitmask</code>, é possível fazer qualquer operação de <code>bitwise</code>.<br  />
</p>

<p>
Por exemplo:<br  />
</p>
<div class="org-src-container">

<pre class="src src-C++"><span style="color: #94BFF3;">#include</span> <span style="color: #CC9393;">&lt;iostream&gt;</span>
<span style="color: #94BFF3;">#include</span> <span style="color: #CC9393;">&lt;iomanip&gt;</span>

<span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">main</span>()
{
    <span style="color: #BFEBBF;">std</span>::cout &lt;&lt;  <span style="color: #BFEBBF;">std</span>::resetiosflags(<span style="color: #BFEBBF;">std</span>::<span style="color: #BFEBBF;">ios_base</span>::dec)
              &lt;&lt;  <span style="color: #BFEBBF;">std</span>::setiosflags(  <span style="color: #BFEBBF;">std</span>::<span style="color: #BFEBBF;">ios_base</span>::hex
                                   | <span style="color: #BFEBBF;">std</span>::<span style="color: #BFEBBF;">ios_base</span>::uppercase
                                   | <span style="color: #BFEBBF;">std</span>::<span style="color: #BFEBBF;">ios_base</span>::showbase) &lt;&lt; 42 &lt;&lt; <span style="color: #CC9393;">'\n'</span>;
}

<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">Output:</span>
<span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">0X2A</span>
</pre>
</div>


<p>
Isso é o básico. Mais informações estão <a href="http://en.cppreference.com/w/cpp/io/manip">aqui</a>.<br  />
</p>
</div>
</div>

<div id="outline-container-sec-3-3-7" class="outline-4">
<h4 id="sec-3-3-7">Deque</h4>
<div class="outline-text-4" id="text-3-3-7">
<p>
Bem, esse problema refere-se ao uso do container Deque da STL.<br  />
É dado um array, o seu tamanho e um índice K. O problema deseja saber<br  />
quais são os valores máximos para cada subarray contínuo divididos em K.<br  />
</p>

<p>
Exemplo: [9,2,3,5,8], k=3<br  />
</p>

<p>
[9,2,3] =&gt; 9<br  />
[2,3,5] =&gt; 5<br  />
[3,5,8] =&gt; 8<br  />
</p>

<p>
Uma aproximação ingênua nos levaria a fazer um algoritmo O(nk). Mas,<br  />
percebendo que é somente necessário n comparações, com o auxílio de um deque<br  />
é possível armazenar os índices úteis dos valores para cada sub-array.<br  />
Complexidade de Espaço: O(k).<br  />
</p>

<p>
A idéia principal é criar um deque ordenado de maior valor ao menor, inserindo<br  />
os índices do array. Quando terminar o subarray, imprimir a cabeça do deque<br  />
e remover se ele não pertencer ao próximo array. Lembre-se que para cada sub-array,<br  />
os indices x &lt;= (i - k) não pertencem mais ao sub-array.<br  />
</p>

<p>
Uma aproximação ótima pode ser descrita nesta implementação: <a href="https://github.com/ryukinix/cpp-journey/tree/master/STL/Deque.cpp">Deque.cpp</a><br  />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">C++ prime checking</h2>
<div class="outline-text-2" id="text-4">
<p>
Usei as bibliotecas:<br  />
</p>
<div class="org-src-container">

<pre class="src src-C++"><span style="color: #94BFF3;">#include</span> <span style="color: #CC9393;">&lt;iostream&gt;</span>
<span style="color: #94BFF3;">#include</span> <span style="color: #CC9393;">&lt;cstdlib&gt;</span>
<span style="color: #94BFF3;">#include</span> <span style="color: #CC9393;">&lt;cmath&gt;</span>
</pre>
</div>
<p>
Em iostream usei apenas cout. cstdlib precisei para a função atoi.<br  />
cmath para sqrt.<br  />
A linha de comando para compilação foi:<br  />
<code>g++ source.cpp -o primep -lm</code><br  />
</p>

<p>
O arquivo pode ser encontrado em: <a href="https://github.com/ryukinix/cpp-journey/tree/master/Intro/primep.cpp">Prime Checking</a><br  />
</p>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Estudos de caso</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">Listas de inicialização para construtores</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Listas de inicialização é um tipo de sintaxe para escrever<br  />
brevemente construtores de classes, geralmente para inicializar valores.<br  />
A sintaxe é usada como a seguir:<br  />
</p>

<div class="org-src-container">

<pre class="src src-C++"><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">Node</span> {
   <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">value</span>;
   <span style="color: #7CB8BB;">Node</span>* <span style="color: #DFAF8F;">next</span>;
   <span style="color: #93E0E3;">Node</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">v</span> = 0, <span style="color: #7CB8BB;">Node</span>* <span style="color: #DFAF8F;">ptr</span>): value(v), <span style="color: #7CB8BB;">next</span>(<span style="color: #DFAF8F;">ptr</span>){};
}
</pre>
</div>

<p>
Dessa maneira, é possível construir de maneiras muito simplórias construtores<br  />
que apenas relacionam entradas de função para atributos de um objeto.<br  />
</p>

<p>
Vale lembrar que a ordem de inicialização deve estar de acordo com a declaração<br  />
dos membros. De acordo com um membro do StackOverflow, em <a href="https://stackoverflow.com/questions/1242830/constructor-initialization-list-evaluation-order">Constructor initialization-list evaluation order</a>,<br  />
foi dito que:<br  />
</p>

<p>
"The reason for which they are constructed in the member declaration order<br  />
and not in the order in the constructor is that one may have several<br  />
constructors, but there is only one destructor.<br  />
And the destructor destroy the members in the reserse order of construction.<br  />
– AProgrammer"<br  />
</p>

<p>
Ou seja, por conta de dependência entre os possíveis valores, a dependência<br  />
é que o destruidor destrói os membros de um objeto na ordem inversa de<br  />
construção, logo, a ordem importa e deve ser mantida.<br  />
</p>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">Separadores de escopo <code>::</code> e <code>.</code></h3>
<div class="outline-text-3" id="text-5-2">
<p>
   O operador <code>::</code> é usado como separador de escopo e acessar<br  />
métodos/atributos estáticos. Por outro lado, <code>.</code> é usado apenas para<br  />
acessar métodos/atributos de uma classe/struct que tenha instância. Além disso,<br  />
o operador <code>-&gt;</code> é usado no lugar de <code>.</code> quando o objeto é um ponteiro.<br  />
Ou seja, na verdade, <code>(*a).b</code> &lt;=&gt; <code>a-&gt;b</code>. Ou seja, <code>-&gt;</code> é apenas uma açúcar<br  />
sintático.<br  />
</p>

<p>
No StackOverflow, novamente, é possível ver uma resposta semelhante onde é<br  />
citado o que foi dito acima.<br  />
<a href="https://stackoverflow.com/questions/2896286/whats-the-difference-between-dot-operator-and-scope-resolution-operator">What's the difference between dot operator and scope resolution operator?</a><br  />
</p>
</div>
</div>
</div>
