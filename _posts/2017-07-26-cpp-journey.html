---
date: 2017-07-26
tags:
- dummy-tags-should-be-replaced
author: Manoel Vilela
layout: post
title: C++ Journey
excerpt: Uma jornada no mundo infernal de C++ através do HackerRank
categories:
- C++
- Programming
---


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="done DONE">DONE</span> HackerRank C++</h2>
<div class="outline-text-2" id="text-1">
</div>
<ul class="org-ul"><li><a id="sec-1-0-1" name="sec-1-0-1"></a><span class="done DONE">DONE</span> The Type String<br  /><div class="outline-text-4" id="text-1-0-1">
<p>
Diferentemente de C, C++ implementa um tipo string não somente como uma cadeia
de caracteres, mas como um objeto. Possui métodos associados, como length.
É bem útil.
</p>


<div class="org-src-container">

<pre class="src src-cpp">// inicialização de string
string a = "abc";
// tamanho
a.size()
// concatenação
string b = "def"
string c = a + b; // "abcdef"
</pre>
</div>

<p>
O primeiro exercício do HackerRank:
</p>

<div class="org-src-container">

<pre class="src src-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
using namespace std;

int main() {
    string a,b;
    cin &gt;&gt; a;
    cin &gt;&gt; b;
    cout &lt;&lt; a.size() &lt;&lt; " " &lt;&lt; b.size() &lt;&lt; endl;
    cout &lt;&lt; a + b &lt;&lt; endl;
    char temp = a[0];
    a[0] = b[0];
    b[0] = temp;
    cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl;

    return 0;
}
</pre>
</div>


<p>
Lidando com tamanho, concatenação e substituição de characteres
em strings.
</p>
</div>
</li>

<li><a id="sec-1-0-2" name="sec-1-0-2"></a><span class="done DONE">DONE</span> Streams<br  /><div class="outline-text-4" id="text-1-0-2">
<p>
Esse tópico refere-se ao gerenciamento de stream usando strings
para C++. Muito interessante. O operador &lt;&lt; insere informação,
por outro lado, o operador &gt;&gt; extrai informação.
</p>


<p>
O método ss cria stringstream cria uma stream. O cabeçalho é sstream.
<a href="Strings/strings-2.cpp">File: HackerRank-Problem-String</a>
O método sstream::eof verifica se a stream está no fim. EOF = End Of File.
</p>
</div>
</li>

<li><a id="sec-1-0-3" name="sec-1-0-3"></a><span class="done DONE">DONE</span> Attribute Parser<br  /><div class="outline-text-4" id="text-1-0-3">
<p>
Nessa atividade, a última de strings, vou precisar fazer um parser de atributos
em Cancer++. Um pouco da descrição do site é dada no block de código abaixo.
</p>

<div class="org-src-container">

<pre class="src src-xml">We have defined our own markup language HRML. In HRML, each element consists of
a starting and ending tag, and there are attributes associated with each tag.
Only starting tags can have attributes. We can call an attribute by referencing
the tag, followed by a tilde, '~' and the name of the attribute.
The tags may also be nested.

Sample Input

4 3
&lt;tag1 value = "HelloWorld"&gt;
&lt;tag2 name = "Name1"&gt;
&lt;/tag2&gt;
&lt;/tag1&gt;
tag1.tag2~name
tag1~name
tag1~value

Sample Output

Name1
Not Found!
HelloWorld
</pre>
</div>

<p>
A atividade está sendo desenvolvida no arquivo:
<a href="Strings/strings-3-attribute-parser.cpp">File: Attribute Parser</a>
</p>

<p>
Já estou há várias horas resolvendo esse problema. Sinceramente é um pouco
trabalhoso. Agora é <span class="timestamp-wrapper"><span class="timestamp">&lt;2017-07-06 qui 01:50&gt;</span></span>. Já se passou mais de 8 horas&#x2026;
que inferno! Mas eu dormi um pouco antes também. Cassete! terminei agora depois
de 14 horas! Uma completa desgraça! KKK
</p>

<p>
QUE INFERNO!!!!!! TERMINEI!!!!
</p>

<p>
Primeiramente interpretei o problema um tanto errado, pensando que a primeira
tag seria a raíz da árvore. O que deu bastante problema para contornar.
Após isso havia vários erros, como o não tratamento de espaços antes das chaves,
como indentação. Isso não parece ter nenhum efeito durante a correção. Mas
só fui perceber todos os erros após conseguir o SUITE TESTCASE #4 de um
repositório do github. O problema central, depois de corrigir a modelagem errada,
era em relação ao método de pesquisa.
**
</p>
</div>
</li>
<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="done DONE">DONE</span> Classes &amp;&amp; OO</h3>
<div class="outline-text-3" id="text-1-1">
</div>
<ul class="org-ul"><li><a id="sec-1-1-1" name="sec-1-1-1"></a><span class="done DONE">DONE</span> Introdução de C++ com Orientação a Objetos<br  /><div class="outline-text-4" id="text-1-1-1">
<p>
Estou fazendo alguns exercícios de C++ no HackerRank. Até agora não estou
com muitos problemas. Na verdade C++ não é tão difícil quanto eu pensei.
De fato, na verdade, eu nunca tinha parado pra olhar direito como era a
linguagem e só ficava de tretinha básica.
</p>

<p>
OO em C++ parece ser divertido, apesar de ainda ter uma impressão cancerígina.
Não é pra menos&#x2026; keywords, friend, public, private e protected?
Mas, enfim, acho que vou conseguir me acostumar. Quero terminar hoje ainda a
introdução, estou na última parte envolvendo OO, herança e variáveis estáticas.
</p>

<p>
Método virtuais em C++ são usados para fazer polimorfismo dinâmicos em heranças.
Protected são membros acessíveis apenas pelas subclasses. Private são
acessíveis apenas pelos métodos da classe. Public são publicos para todos.
</p>

<p>
Por padrão, membros são privados em classes. É possível usar a keyword friend
para acessar atributos privados de outra classe. Provavelmente eu não deveria
estar falando desses tópicos avançados de OO na introdução (HAHAH!). Mas
é bom que dá o gostinho de desgraça que C++ tem tanto de especial.
</p>
<div class="org-src-container">

<pre class="src src-cpp">const int NUMBER_OF_MARKS = 6;

class Person {
protected:
    string name;
    int age;
public:
    virtual void putdata(void){};
    virtual void getdata(void){};
};

class Professor: public Person {
private:
    int publications;
    int cur_id;
public:
    static int count;
    Professor(void){
        cur_id = count + 1;
        count += 1;
    }
    virtual void putdata(void) {
        // The function putdata should print the name, age, publications and the cur_id of the professor.
        cout &lt;&lt; name &lt;&lt; " ";
        cout &lt;&lt; age &lt;&lt; " ";
        cout &lt;&lt; publications &lt;&lt; " ";
        cout &lt;&lt; cur_id &lt;&lt; endl;
    }

    virtual void getdata(void) {
        cin &gt;&gt; name;
        cin &gt;&gt; age;
        cin &gt;&gt; publications;
    }
};

class Student: public Person {
private:
    int marks[NUMBER_OF_MARKS];
    int _sum_marks() {
        int total = 0;
        for (int i = 0; i &lt; NUMBER_OF_MARKS; i++) {
            total += marks[i];
        }
        return total;
    }
    int cur_id;
public:
    static int count;
    Student(void) {
        cur_id = count + 1;
        count += 1;
    }
    virtual void putdata(void) {
        // The function putdata should print the name, age, sum of the marks and the cur_id of the student.
        cout &lt;&lt; name &lt;&lt; " ";
        cout &lt;&lt; age &lt;&lt; " ";
        cout &lt;&lt; _sum_marks() &lt;&lt; " ";
        cout &lt;&lt; cur_id &lt;&lt; endl;

    }

    virtual void getdata(void) {
        cin &gt;&gt; name;
        cin &gt;&gt; age;
        for (int i = 0; i &lt; NUMBER_OF_MARKS; i++){
            cin &gt;&gt; marks[i];
        }

    }

};

int Professor::count = 0;
int Student::count = 0;
</pre>
</div>

<p>
Construtores podem ser definidos uma ou várias vezes.
No entanto, destrutores só podem ser definidos uma vez.
</p>
</div>
</li>

<li><a id="sec-1-1-2" name="sec-1-1-2"></a><span class="done DONE">DONE</span> Structs<br  /><div class="outline-text-4" id="text-1-1-2">
<p>
Os structs em C++ são semelhantes de C, no entanto eles são como classes
com membros e métodos públicos por padrão. Usualmente structs são usados apenas
para agrupar membros de variáveis numa estrutura compartilhada, podendo assim,
criar estrutura de dados mais complexas.
</p>
</div>
</li>

<li><a id="sec-1-1-3" name="sec-1-1-3"></a><span class="done DONE">DONE</span> Básico de Classes<br  /><div class="outline-text-4" id="text-1-1-3">
<p>
Por padrão classes tem seus métodos e atributos privados, sendo reservado as
keywords para controle de acesso: protected, private e public.
Uma prática comum em C++ é deixar todos os atributos privados ou protecteds
(case for uma classe base de herança), então criar getters e setters públicos.
</p>

<p>
Um exemplo de código abaixo é dado:
</p>

<div class="org-src-container">

<pre class="src src-cpp">class Student {
private:
    string name;
    int age;
public:
    string get_mame() {
        return name;
    }

    string get_age() {
        return age;
    }

    void set_name(string new_name) {
        name = new_name;
    }

    void set_age(int new_age) {
        age = new_age;
    }
}
</pre>
</div>
</div>
</li>

<li><a id="sec-1-1-4" name="sec-1-1-4"></a><span class="done DONE">DONE</span> Class constructors<br  /><div class="outline-text-4" id="text-1-1-4">
<p>
Construtores são chamados na inicialização de uma classe. Podem ter um ou mais,
com diferentes assinaturas.
Os tipos de construtores são três:
</p>
<ol class="org-ol">
<li>Construtor padrão
</li>
<li>Construtor parametrizado
</li>
<li>Construtor de Cópia
</li>
</ol>
<p>
<a href="Classes/constructor.cpp">File: ConstructorsExample</a>
</p>
</div>
</li>

<li><a id="sec-1-1-5" name="sec-1-1-5"></a><span class="done DONE">DONE</span> Exceptions<br  /><div class="outline-text-4" id="text-1-1-5">
<p>
C++ permite criar exceções personalizadas ao criar uma herança da classe
`exception`. O método descritivo da exceção é `const char* what(){}`.
Uma atividade simples foi feita em: <a href="Classes/exception.cpp">Exceptions.cpp</a>
Blocos try/catch são usados pra lidar com exceções que ocorreram.
throw Exception(); é usado para sinalizar uma exceção.
</p>

<p>
Minha proxima atividade no HackerRank é a respeito de um servidor para
capturar exceções customizadas.
<a href="Classes/CustomExceptions.cpp">CustomExceptions.cpp</a>
</p>

<p>
Todas as exceções padrões tem como base classe <b>std::exception</b>.
Uma maneira simples de capturar uma exceção e imprimi-la, é desta maneira:
</p>

<p>
#+NAME Exemplo de captura de exceção
</p>
<div class="org-src-container">

<pre class="src src-cpp">#include &lt;exception&gt; // definição da classe base std::exception
#include &lt;stdexcept&gt; // várias exceções padrões para ser usadas
try {
    std::cout &lt;&lt; 1/0;
} catch(std::exception const&amp; e) {
    std::cout &lt;&lt; "Erro do capeta: " &lt;&lt; e.what();
} catch(...) {
    // essa sessão captura qualquer exceção não esperada
}
</pre>
</div>

<p>
Exceções definidas no cabeçalho &lt;stdexcept&gt;
</p>
<ul class="org-ul">
<li>bad<sub>alloc</sub>
</li>
<li>bad<sub>cast</sub>
</li>
<li>bad<sub>exception</sub>
</li>
<li>bad<sub>typeid</sub>
</li>
<li>logic<sub>error</sub>
<ul class="org-ul">
<li>domain<sub>error</sub>
</li>
<li>invalid<sub>argument</sub>
</li>
<li>length<sub>error</sub>
</li>
<li>out<sub>of</sub><sub>range</sub>
</li>
</ul>
</li>
<li>runtime<sub>error</sub>
<ul class="org-ul">
<li>range<sub>error</sub>
</li>
<li>overflow<sub>error</sub>
</li>
<li>underflow<sub>error</sub>
</li>
</ul>
</li>
</ul>
</div>
</li>
<li><a id="sec-1-1-6" name="sec-1-1-6"></a><span class="done DONE">DONE</span> Polymorphism and Abstract Base Classes<br  /><div class="outline-text-4" id="text-1-1-6">
<p>
Comecei a fazer essa atividade agora às <span class="timestamp-wrapper"><span class="timestamp">&lt;2017-07-06 qui 20:51&gt;</span></span>.
Polimorfismo é quando um método na herança é modificado. Em C++
existem as chamadas Classes Abstratas de Base, onde é permitido que elas
possuam apenas métodos virtuais para futuramente, numa herança, realizar
polimorfismo.
</p>

<p>
Essa última atividade é bem cabulosa. O objetivo é implementar um sistema
de cache usando listas duplamente encadeadas e, além disso, fazer de tal maneira
que use os conceitos referentes a polimorfismo numa classe chamada Cache.
</p>

<p>
As atividades a serem desenvolvidas aqui podem ser encontradas em:
<a href="Classes/AbstractPolymorphism.cpp">AbstractPolymorphism.cpp</a>.
</p>

<p>
Depois de um dia tentando ter um progresso com essa atividade, já consegui
implementar a funcionalidade básica do Cache. No entanto, os tests com maiores
entradas estão com problemas. De acordo com a execução do HackerRank, está
ocorrendo segfault. Acredito que possa ser devido o não tratamento direto
da desalocação dos objetos Nó durante a chamada de void pop<sub>node</sub>(); que
desaloca a cauda da lista. Contínuo essa atividade mais tarde.
</p>

<p>
De fato durante o pop<sub>node</sub>(); há um vazamento de memória. A referência do objeto
é perdida, mas no entanto o objeto em si não é removido. Foi realizado uma
verificação manual na versão deste [commit](bb6741d41c74cca1974bb41f3cd0f865a0d7be2c).
A estratégia assumida é para gerenciar corretamente a memória durante as novas
alocações.
</p>

<p>
Como eu suspeitava, a função LRUCache::pop<sub>node</sub>() que estava vazando memória.
Após a adição das instruções pra desalocar tanto a cauda como também a entrada
desse nó no HashMap mp, os testes do HackerRank passaram. Mas demorei demais pra
fazer tudo. Quase 30 horas! Bem que no HackerRank comentava que era uma questão
difícil.
</p>
</div>
</li></ul>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="done DONE">DONE</span> Inheritance</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Este é um tópico especial envolvendo como funciona o conceito de herança
em C++, todo mal da orientação objetos, como também é uma prática comum
em muitos projetos que usam linguagens como C++.
</p>

<p>
Estarei linkando nos próximos títulos os códigos-fontes de cada
solução das questões.
</p>
</div>

<ul class="org-ul"><li><a id="sec-1-2-1" name="sec-1-2-1"></a><span class="done DONE">DONE</span> Inheritance Introduction<br  /><div class="outline-text-4" id="text-1-2-1">
<p>
Nessa atividade é pedido pra construir um método de descrição de uma subclasse
de Triangle chamada Isosceles. A construção é bem direta e não é necessário
muita explicação. É tão estúpida que até pensei em não deixar o código fonte aqui.
Mas vamos lá&#x2026; <a href="Inheritance/TriangleInheritance.cpp">TriangleInheritance.cpp</a>
</p>
</div>
</li>

<li><a id="sec-1-2-2" name="sec-1-2-2"></a><span class="done DONE">DONE</span> Rectangle Area<br  /><div class="outline-text-4" id="text-1-2-2">
<p>
Nesta atividade será feito um exercício para cálculo
da área de um retângulo usando os conceitos de herança. Durante
a construção da solução foi possível perceber que era possível
chamar métodos da classe base com mesmo nome, no caso ambos possuiam
o método void display, mas a instância do objeto era RectangleArea.
Para acessar então, display de Rectangle, foi necessário a seguinte
sintaxe:
</p>

<div class="org-src-container">

<pre class="src src-cpp">RectangleArea r_area;
r_area.Rectangle::display();
</pre>
</div>

<p>
A solução completa pode ser encontrada aqui:
<a href="Inheritance/RectangleArea.cpp">RectangleArea.cpp</a>
</p>
</div>
</li>

<li><a id="sec-1-2-3" name="sec-1-2-3"></a><span class="done DONE">DONE</span> Multi Level Inheritance<br  /><div class="outline-text-4" id="text-1-2-3">
<p>
     É possível fazer herança em mais de um nível. Um exemplo é dado
no exercício para a construção de uma classe Equilateral, que deriva
de Isosceles, que é derivado de Triangle. Isso demonstra a interdependência
das propriedades que uma instância de Equilateral tem entre Isosceles
e Triangle. O que é realmente verdade, já que um triângulo Equilátero
é obviamente também um Triângulo e é Isósceles.
</p>

<p>
A atividade foi direta de ser completa e está descrita a seguir:
<a href="Inheritance/IsoscelesEquilateral.cpp">IsoscelesEquilateral.cpp</a>
</p>
</div>
</li>

<li><a id="sec-1-2-4" name="sec-1-2-4"></a><span class="done DONE">DONE</span> Accessing Inherited Functions<br  /><div class="outline-text-4" id="text-1-2-4">
<p>
     Como comentada na questão Rectangle Area, é possível acessar
funções/métodos da classe base que foi herdada. Nessa atividade
irei descrever brevemente a implementação do exercício proposto no
HackerRank.
</p>

<p>
A atividade é descrita em: <a href="Inheritance/AcessingInheritedFunctions.cpp">AcessingInheritedFunctions.cpp</a>
</p>

<p>
A questão pede para se chegar a um número de entrada usando apenas as classes
de base A, B e C.
</p>
</div>
</li>
<li><a id="sec-1-2-5" name="sec-1-2-5"></a><span class="done DONE">DONE</span> Magic Spells<br  /><div class="outline-text-4" id="text-1-2-5">
<p>
Lá vem questão HARD de novo do inferno do HackerRank. Essa questão
envolve o uso de herança e dynamic<sub>cast</sub>, que é basicamente o que tentei fazer
uma vez em C e só me fudi (uma variável de tipo dinâmico). Parece que C++
implementa algo parecido do que eu desejei pra lidar com esse tipo de problema.
</p>

<p>
Nesse caso dynamic<sub>cast</sub> é usado para modelar uma instância compatível com outro tipo
ou classe. Se um ponteiro é retornado, significa que os tipos não são compatíveis.
Nessa questão isso é usado para saber que tipo de que classe derivada de Spell
foi instanciada. A sintaxe é dada por dynamic<sub>cast</sub>&lt;Type*&gt;(instance*). Muito
semelhante ao cast estático de C.
</p>

<p>
Estou tendo alguns problemas para construir um algoritmo do tipo LCS.
Isto é: Longest Common Substring. Quando o spell é da classe Base, out seja,
um tipo de magia desconhecida, é necessário que o mago olhe no catálogo de magias
e compare o nome da magia com o que foi recebido. Dada as duas strings, a recebida
e a do catálogo, devo retornar o tamanho da substring maior.
</p>

<p>
Ou seja, é dado o exemplo que para AquaVitae e AruTaVae a maior substring é
AuaVae. Não tenho tanta certeza se isso está correto, mas achei um código exemplo
em C++ pra testar. Está linkado em <a href="Inheritance/LongestCommonSubstring.cpp">LongestCommonSubstring.cpp</a>
</p>

<p>
Minha desconfiança sobre isso é da natureza que esse exemplo não retorna
exatamente a maior substring e sim a maior cadeia possível em sequência, se
necessário, removendo o que tiver no meio entre elas.
</p>

<p>
Vou dar uma pausa aqui nessa atividade agora às <span class="timestamp-wrapper"><span class="timestamp">&lt;2017-07-08 sáb 13:48&gt;</span></span>.
Depois vou tentar voltar mais tarde. A parte inicial da atividade está feita
em: <a href="Inheritance/MagicSpells.cpp">MagicSpells.cpp</a>
</p>

<p>
Estou de volta nessa atividade dos demônios. Realmente a detecção das classes
filhas ao usar dynamic cast estão funcionando bem. Na verdade dynamic cast é
um pouco diferente do que pensei, você não pode fazer conversão de tipos
arbitrários, mas sim àqueles que são possíveis. Como no caso de um instância
Pai para uma classe Filha (derivada, herdada).
</p>

<p>
No entanto estou com problemas demais em relação a desgraça do algoritmo
para de cálculo de maior substring recorrente entre duas strings, pois esse
problema de fato não é o Longest Common Substring. Vou precisar fazer um algoritmo
personalizado pra isso. Talvez eu devesse começar fazendo em Python pra facilitar
a lógica e depois passar pra Câncer++.
</p>

<p>
Agora tudo faz sentido, eu estava tentando resolver um problema com a solução
para outro tipo de problema. Esse problema na verdade tem outro nome. Apesar
de semelhante ao Longest Common Substring, este se chama Longest Common
Subsequence. Uma solução em Python transcrita de um pseudo código pode ser vista
abaixo:
</p>

<div class="org-src-container">

<pre class="src src-python">def LCSLength(X, Y):
    from pprint import pprint
    m, n = len(X) + 1, len(Y) + 1
    C = [[0 for _ in range(n)] for _ in range(m)]
    for i in range(1, m):
        for j in range(1, n):
            if X[i-1] == Y[j-1]:
                C[i][j] = C[i-1][j-1] + 1
            else:
                C[i][j] = max(C[i][j-1], C[i-1][j])
    pprint(C)
    return C[n-1][m-1]
</pre>
</div>

<p>
Vou tentar agora codificar isso em C++. Finalizado. Que desgraça hein.
A parte mais difícil desse problema não era exatamente lidar com o dynamic<sub>cast</sub>
e detectar que classe filha estão sendo referenciadas. Na verdade esse problema
aí do Longest Common Subsequence é bem mais difícil. Engraçado porque esse tópico
é sobre herança, o que esse problema NP-Hard é simplemente sem relação!
</p>

<p>
Mas terminado. Agora está tudo ok!
</p>
</div>
</li></ul>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="done DONE">DONE</span> STL :: C++ Standard Library</h3>
<div class="outline-text-3" id="text-1-3">
</div>
<ul class="org-ul"><li><a id="sec-1-3-1" name="sec-1-3-1"></a><span class="done DONE">DONE</span> STL - Vector Sort<br  /><div class="outline-text-4" id="text-1-3-1">
<p>
A Standard Library de C++ vem com muitos bultins. Um dos métodos
da biblioteca é std::sort(vector::begin, vector::end).
</p>

<div class="org-src-container">
<label class="org-src-name">Ordenar n números</label>
<pre class="src src-cpp">#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;


int main() {
    int n, x;
    cin &gt;&gt; n;
    vector&lt;int&gt; v;
    for(int i = 0; i &lt; n; i++) {
        cin &gt;&gt; x;
        v.push_back(x);
    }
    sort(v.begin(), v.end());
    for(int x :v) {
        cout &lt;&lt; x &lt;&lt; " ";
    }
    return 0;
}
</pre>
</div>
</div>
</li>
<li><a id="sec-1-3-2" name="sec-1-3-2"></a><span class="done DONE">DONE</span> Vector-Erase<br  /><div class="outline-text-4" id="text-1-3-2">
<p>
A STL definida em &lt;algorithm&gt; e &lt;vector&gt; define alguns métodos
úteis, como por exemplo o método vector::erase para remover elementos
seja de apenas 1 localização, ou um intervalo.
</p>

<p>
O seguinte código foi feito para o exercício proposto do hackerrank:
</p>
<div class="org-src-container">

<pre class="src src-cpp">#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;


int main() {
    vector&lt;long&gt; v;
    int n,x,a,b;
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++) {
        cin &gt;&gt; x;
        v.push_back(x);
    }

    cin &gt;&gt; x;
    v.erase(v.begin()+x-1);
    cin &gt;&gt; a;
    cin &gt;&gt; b;
    v.erase(v.begin()+a-1, v.begin()+b-1);
    cout &lt;&lt; v.size() &lt;&lt; endl;

    for (int x : v) {
        cout &lt;&lt; x &lt;&lt; " ";
    }
    return 0;
}
</pre>
</div>

<p>
Ou seja, há duas definições para vector::erase.
</p>
<ul class="org-ul">
<li>vector::erase(const iterator n);
</li>
<li>vector::erase(const iterator n, const iterator m);
</li>
</ul>

<p>
O const iterator pode ser obtido a partido dos métodos:
vector::begin e vector::end.
</p>
</div>
</li>

<li><a id="sec-1-3-3" name="sec-1-3-3"></a><span class="done DONE">DONE</span> Lower Bound-STL<br  /><div class="outline-text-4" id="text-1-3-3">
<p>
Em C++ a STL provém funções úteis para iterações e comparações.
Um delas são os métodos std::lower<sub>bound</sub> e std::upper<sub>bound</sub>.
Ambas funções recebem três parâmetros, os dois primeiros sendo
o iterador inicial então o iterador final (vector::begin &amp; vector::end).
O terceiro elemento é um objeto de comparação que implementa operator&lt;
para std::lower<sub>bound</sub> e std::upper<sub>bound</sub>.
</p>

<p>
O método std::lower<sub>bound</sub> retorna o número menor que a comparação que esteja
mais próximo desse número esquerda. std::upper<sub>bound</sub> retorna o maior número que esteja
mais próximo desse pela direita. Isso, é claro supondo um vetor ordenado.
</p>

<p>
Pode-se encontrar uma solução para este problema no arquivo:
<a href="STL/LowerBound.cpp">LowerBound.cpp</a>
</p>
</div>
</li>

<li><a id="sec-1-3-4" name="sec-1-3-4"></a><span class="done DONE">DONE</span> Sets-STL<br  /><div class="outline-text-4" id="text-1-3-4">
<p>
Essa próxima atividade se refere a implementação de conjuntos na biblioteca
padrão de C++. Definida no cabeçalho `#include &lt;set&gt;` os métodos conhecidos para
o tipo set, são:
</p>

<ul class="org-ul">
<li>std::set&lt;int&gt; s;
</li>
<li>s.length(); // tamanho do conjunto
</li>
<li>s.erase(int n); // apagar um elemento
</li>
<li>s.insert(int n); // inserir um elemento
</li>
<li>set&lt;int&gt;::iterator it = s.find(int n); // procura um elemento, devolve um iterator
</li>
</ul>

<p>
Se o elemento não é encontrado it == s.end();
</p>

<p>
Um problema para explorar essas operações é proposto no HackerRank,
onde uma solução pode ser encontrada aqui: <a href="STL/Set.cpp">Set.cpp</a>
</p>
</div>
</li>

<li><a id="sec-1-3-5" name="sec-1-3-5"></a><span class="done DONE">DONE</span> Maps-STL<br  /><div class="outline-text-4" id="text-1-3-5">
<p>
HashMaps são implementados em C++ pela STL, Standard Library. Também conhecidos
em outras linguagens como dicionários (python), HashMaps armazenam unidades de
de pares &lt;chave, valor&gt; na qual a existência para uma dada chave é única.
</p>

<p>
Existem alguns métodos úteis implementados para HashMaps. O tipo é definido
em `#include &lt;map&gt;` e segue que:
</p>

<div class="org-src-container">

<pre class="src src-cpp">#include &lt;map&gt;

std::map&lt;int, string&gt; m; // declaração
m.insert(std::make_pair(1, "banana")); // inserção
m[1] = "banana"; // açucar sintático para inserção
m.erase("banana"); //remover elemento
m.find(key); // m&lt;int,string&gt;::iterator
// se um elemento não é encontrado então m.find(key) == m.end();
m[1]; // "banana
</pre>
</div>

<p>
Um problema é proposto no HackerRank para explorar essas operações.
A implementação está feita no arquivo <a href="STL/HashMap.cpp">HashMap.cpp</a>.
</p>
</div>
</li>

<li><a id="sec-1-3-6" name="sec-1-3-6"></a><span class="done DONE">DONE</span> Print Pretty<br  /><div class="outline-text-4" id="text-1-3-6">
<p>
Preciso fazer essa atividade. Irei começar daqui a pouco. Basicamente
a atividade é em relação a imprimir diferente tipos de dados com uma determinada
característica. Por exemplos, notação científica para decimais. Números
decimais prefixado e também números inteiros com caracteres prefixado.
Parece que STL já implementa isso em algum lugar.
</p>

<p>
A atividade será desenvolvida em: <a href="STL/PrettyPrint.cpp">PrettyPrint.cpp</a>
</p>

<p>
Maiores anotações virão a seguir.
</p>

<p>
Bem&#x2026; trabalhar com formatação de IO em C++ é no mínimo doloroso.
Na verdade eu achei um completo inferno, mas vou tentar descrever algumas coisas
que entendi.
</p>

<p>
No cabeçalho &lt;iomanip&gt; é definido várias entradas para trabalhar com formatação
de stringstreams, ou necessariamente IO.
</p>

<p>
Entre diretrizes pra trabalhar com números de qualquer tipo tem-se:
</p>

<ul class="org-ul">
<li>showbase &#x2013; mostra a base do número, como hex e octal
</li>
<li>noshowbase &#x2013; desativa a opção acima
</li>
<li>showpos &#x2013; todos números são definidos com sinal prefixado +/-
</li>
<li>noshowpos &#x2013; desativa a opção acima
</li>
<li>setbase &#x2013; define qual é a base no parsing, por exemplo 16 -&gt; hexadecimal
</li>
<li>uppercase &#x2013; base e outros caracteres são usados em uppercase
</li>
<li>nouppercase &#x2013; o contrário da opção acima
</li>
</ul>

<p>
Para setbase temos atalhos predefinidos como `hex`, `oct` e `dec`.
</p>

<p>
Para preenchimento de string, largura máxima e alinhamento temos:
</p>

<ul class="org-ul">
<li>left &#x2013; alinha pela esquerda
</li>
<li>right &#x2013; alinha pela direita
</li>
<li>internal &#x2013; aplica a formação no número em si
</li>
<li>setw &#x2013; define largura máxima
</li>
<li>setfill &#x2013; recebe um caracter e preenche de acordo com a largura máxima esperada
</li>
</ul>

<p>
Para processamento de números flutuantes temos:
</p>

<ul class="org-ul">
<li>setprecision &#x2013; precisão em casas decimais
</li>
<li>fixed &#x2013; notação prefixa =&gt; 10.001
</li>
<li>scientific &#x2013; notação científica-&gt; 3.30303E+03
</li>
<li>default &#x2013; notação padrão
</li>
</ul>

<p>
Também tem hexfloat, mas isso é muito obscuro e não vou cobrir.
</p>


<p>
Para fazer uma definição global de formação podemos usar setiosflags e resetiosflags.
</p>

<p>
setiosflags recebe uma das flags acima não-parametrizada e define globalmente.
Como o argumento esperado é uma bitmask, é possível fazer qualquer operação de bitwise.
</p>

<p>
Por exemplo:
</p>
<div class="org-src-container">

<pre class="src src-cpp">#include &lt;iostream&gt;
#include &lt;iomanip&gt;

int main()
{
    std::cout &lt;&lt;  std::resetiosflags(std::ios_base::dec)
              &lt;&lt;  std::setiosflags(  std::ios_base::hex
                                   | std::ios_base::uppercase
                                   | std::ios_base::showbase) &lt;&lt; 42 &lt;&lt; '\n';
}

// Output:
// 0X2A
</pre>
</div>


<p>
Isso é o básico. Mais informações estão <a href="http://en.cppreference.com/w/cpp/io/manip">aqui</a>.
</p>
</div>
</li>

<li><a id="sec-1-3-7" name="sec-1-3-7"></a><span class="done DONE">DONE</span> Deque-STL<br  /><div class="outline-text-4" id="text-1-3-7">
<p>
Bem, esse problema refere-se ao uso do container Deque da STL.
É dado um array, o seu tamanho e um índice K. O problema deseja saber
quais são os valores máximos para cada subarray contínuo divididos em K.
</p>

<p>
Exemplo: [9,2,3,5,8], k=3
</p>

<p>
[9,2,3] =&gt; 9
[2,3,5] =&gt; 5
[3,5,8] =&gt; 8
</p>

<p>
Uma aproximação ingênua nos levaria a fazer um algoritmo O(nk). Mas,
percebendo que é somente necessário n comparações, com o auxílio de um deque
é possível armazenar os índices úteis dos valores para cada sub-array.
Complexidade de Espaço: O(k).
</p>

<p>
A idéia principal é criar um deque ordenado de maior valor ao menor, inserindo
os índices do array. Quando terminar o subarray, imprimir a cabeça do deque
e remover se ele não pertencer ao próximo array. Lembre-se que para cada sub-array,
os indices x &lt;= (i - k) não pertencem mais ao sub-array.
</p>

<p>
Uma aproximação ótima pode ser descrita nesta implementação: <a href="STL/Deque.cpp">Deque.cpp</a>
</p>
</div>
</li></ul>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="done DONE">DONE</span> C++ prime checking</h2>
<div class="outline-text-2" id="text-2">
<p>
Usei as bibliotecas:
</p>
<div class="org-src-container">

<pre class="src src-cpp">#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
</pre>
</div>
<p>
Em iostream usei apenas cout. cstdlib precisei para a função atoi.
cmath para sqrt.
A linha de comando para compilação foi:
`g++ source.cpp -o primep -lm`
</p>

<p>
O arquivo pode ser encontrado em: <a href="Intro/primep.cpp">Prime Checking</a>
</p>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="done DONE">DONE</span> Estudos de caso</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="done DONE">DONE</span> Listas de inicialização para construtores</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Listas de inicialização é um tipo de sintaxe para escrever
brevemente construtores de classes, geralmente para inicializar valores.
A sintaxe é usada como a seguir:
</p>

<div class="org-src-container">

<pre class="src src-cpp">struct Node {
   int value;
   Node* next;
   Node(int v = 0, Node* ptr): value(v), next(ptr){};
}
</pre>
</div>

<p>
Dessa maneira, é possível construir de maneiras muito simplórias construtores
que apenas relacionam entradas de função para atributos de um objeto.
</p>

<p>
Vale lembrar que a ordem de inicialização deve estar de acordo com a declaração
dos membros. De acordo com um membro do StackOverflow, em <a href="https://stackoverflow.com/questions/1242830/constructor-initialization-list-evaluation-order">Constructor initialization-list evaluation order</a>,
foi dito que:
</p>

<p>
"The reason for which they are constructed in the member declaration order
and not in the order in the constructor is that one may have several
constructors, but there is only one destructor.
And the destructor destroy the members in the reserse order of construction.
– AProgrammer"
</p>

<p>
Ou seja, por conta de dependência entre os possíveis valores, a dependência
é que o destruidor destrói os membros de um objeto na ordem inversa de
construção, logo, a ordem importa e deve ser mantida.
</p>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="done DONE">DONE</span> Testar separadores de escopo `::` e `.`</h3>
<div class="outline-text-3" id="text-3-2">
<p>
   O operador `::` é usado como separador de escopo e acessar
métodos/atributos estáticos. Por outro lado, `.` é usado apenas para
acessar métodos/atributos de uma classe/struct que tenha instância. Além disso,
o operador `-&gt;` é usado no lugar de `.` quando o objeto é um ponteiro.
Ou seja, na verdade, (*a).b &lt;=&gt; a-&gt;b. Ou seja, `-&gt;` é apenas uma açúcar
sintático.
</p>

<p>
No StackOverflow, novamente, é possível ver uma resposta semelhante onde é
citado o que foi dito acima.
<a href="https://stackoverflow.com/questions/2896286/whats-the-difference-between-dot-operator-and-scope-resolution-operator">What's the difference between dot operator and scope resolution operator?</a>
</p>
</div>
</div>
</div>
